## Prólogo

Educadores, generales, nutricionistas, psicólogos y padres programan. Ejércitos, estudiantes y algunas sociedades son programados. Un asalto a los grandes problemas requiere una sucesión de programas, la mayoría de los cuales surgen en el camino. Estos programas están repletos de cuestiones que parecen ser particulares a cada caso. Para apreciar la programación como una actividad intelectual en su propio derecho, uno debe recurrir a la programación de computadoras; uno debe leer y escribir programas de computadora, muchos de ellos. No importa mucho en qué consistan los programas o qué aplicaciones sirvan. Lo que importa es lo bien que funcionen y qué tan bien encajen con otros programas en la creación de programas aún mayores. El programador debe buscar tanto la perfección de la parte como su adecuación en el conjunto. En este libro el uso de "programar" se centra en la creación, ejecución y estudio de programas escritos en un dialecto de Lisp para su ejecución en una computadora digital. Usando Lisp restringimos o limitamos no lo que podemos programar, sino sólo a la notación para las descripciones de nuestros programas.

Nuestro tránsito con el tema de este libro nos involucra en tres focos de fenómenos: la mente humana, las colecciones de programas de computadora y la computadora misma. Cada programa de computadora es un modelo, incubado en la mente, de un proceso real o mental. Estos procesos, que surgen de la experiencia y el pensamiento humanos, son enormes en número, intrincados en detalle, y en todo momento sólo se comprenden en parte. Son raramente modelados a nuestra satisfacción permanente por nuestros programas informáticos. Así, aunque nuestros programas son colecciones minuciosamente elaboradas de símbolos discretos, mosaicos de funciones entrelazadas, estos evolucionan continuamente: los cambiamos a medida que nuestra percepción del modelo se profundiza, se amplía, se generaliza hasta que el modelo finalmente alcanza un lugar metaestable dentro de otro modelo con el que nos enfrentamos. La fuente de entusiasmo asociado con la programación de computadoras es el continuo despliegue dentro de la mente y de la computadora de los mecanismos expresados como programas y la explosión de percepciones que generan. Si el arte interpreta nuestros sueños ¡la computadora los ejecuta en forma de programas!

A pesar de toda su potencia, la computadora es una severa capataz. Sus programas deben ser correctos, y aquello que queramos decir debe ser dicho con precisión en cada detalle. Como en cualquier otra actividad simbólica, nos convencemos de la verdad del programa a través de argumentos. A Lisp se le puede asignar una semántica (otro modelo, por cierto), y si la función de un programa puede ser especificada -digamos, en el cálculo de predicados-, se pueden usar los métodos de prueba de la lógica para hacer un argumento de corrección aceptable. Desafortunadamente, a medida que los programas se vuelven grandes y complicados, como casi siempre lo hacen, la suficiencia, consistencia y corrección de las especificaciones en sí mismas quedan abiertas a la duda, de modo que los argumentos formales completos de corrección raramente acompañan a los programas grandes. Dado que los programas grandes crecen a partir de programas pequeños, es crucial que desarrollemos un arsenal de estructuras de programas estándar de cuya corrección nos hemos asegurado -las llamamos expresiones idiomáticas- y aprendamos a combinarlas en estructuras más grandes utilizando técnicas organizativas de valor comprobado. Estas técnicas se tratan a fondo en este libro, y su comprensión es esencial para participar en la empresa prometeica llamada programación. Más que cualquier otra cosa, el descubrimiento y el dominio de poderosas técnicas organizativas acelera nuestra capacidad para crear programas grandes y significativos. Por otro lado, dado que escribir grandes programas es muy agotador, se nos anima a inventar nuevos métodos para reducir la masa de funciones y detalles que se deben incluir en los grandes programas.

A diferencia de los programas, las computadoras deben obedecer las leyes de la física. Si deseamos que actúen rápidamente -unos pocos nanosegundos por cambio de estado- deben transmitir electrones sólo a pequeñas distancias (a lo sumo hasta 46 cm.). El calor generado por la gran cantidad de dispositivos tan concentrados en un espacio tiene que ser removido. Se ha desarrollado un fino arte de ingeniería que equilibra la multiplicidad de funciones y la densidad de los dispositivos. En cualquier caso, el hardware siempre opera a un nivel más primitivo de aquel al que nos interesa programar. Los procesos que transforman nuestros programas Lisp en programas "máquina" son en sí mismos modelos abstractos que nosotros programamos. Su estudio y creación dan una gran cantidad de información sobre los programas organizacionales asociados con la programación de modelos arbitrarios. Por supuesto, la computadora misma puede ser modelada. Piénselo: el comportamiento del elemento de conmutación física más pequeño está modelado por la mecánica cuántica descrita por ecuaciones diferenciales cuyo comportamiento detallado es capturado por aproximaciones numéricas representadas en programas de computadora que se ejecutan en computadoras compuestas de...

No es meramente una cuestión de conveniencia táctica identificar por separado los tres focos. A pesar de que, como dicen, todo está en la cabeza, esta separación lógica induce una aceleración del tránsito simbólico entre estos focos cuya riqueza, vitalidad y potencial es superada en la experiencia humana sólo por la evolución de la vida misma. En el mejor de los casos, las relaciones entre los focos son metastables. Las computadoras nunca son lo suficientemente grandes o rápidas. Cada avance en la tecnología de hardware conduce a empresas de programación más masivas, a nuevos principios organizativos y a un enriquecimiento de los modelos abstractos. Cada lector debe preguntarse periódicamente "¿Hacia qué fin, hacia qué fin?, pero no lo haga con demasiada frecuencia para no dejar pasar la diversión de programar en favor del estreñimiento de una filosofía agridulce.

Entre los programas que escribimos, algunos (aunque nunca los suficientes) desempeñan una función matemática precisa, como ordenar o encontrar el máximo de una secuencia de números, determinar si es primo o encontrar la raíz cuadrada. A estos programas los llamamos algoritmos, y se sabe mucho de su comportamiento óptimo, particularmente con respecto a los dos importantes parámetros de tiempo de ejecución y los requisitos de almacenamiento de datos. Un programador debe adquirir buenos algoritmos y expresiones idiomáticas. Aunque algunos programas se resistan a especificaciones precisas, es la responsabilidad del programador estimar y siempre intentar mejorar su rendimiento.

Lisp es un sobreviviente, habiendo estado en uso durante un cuarto de siglo `(NdT: se presume que el autor redactó este prólogo para la 1° edición del libro en 1984, cuando Lisp ya llevaba ese tiempo de vida)`. Entre los lenguajes de programación activos sólo Fortran ha tenido una vida útil más larga. Ambos lenguajes han soportado las necesidades de programación de importantes áreas de aplicación, Fortran para la computación científica y de ingeniería y Lisp para la inteligencia artificial. Estas dos áreas siguen siendo importantes, y sus programadores están tan dedicados a estos dos lenguajes que Lisp y Fortran bien continuarán en uso activo durante al menos otro cuarto de siglo.

Lisp cambia. El dialecto Scheme utilizado en este texto ha evolucionado a partir del Lisp original y difiere de este último en varios aspectos importantes, incluyendo el *ámbito estático* para la *unión de variables* `(NdT: en inglés "static scoping" y "variable binding", respectivamente)` y de permitir que las funciones generen funciones como valores. En su estructura semántica, Scheme se parece tanto a Algol 60 como a los primeros Lisps. Algol 60, que no volverá a ser un lenguaje activo, vive en los genes de Scheme y Pascal. Sería difícil encontrar dos idiomas que sean la moneda de cambio entre dos culturas tan diferentes como las que se reúnen en torno a estos dos idiomas. Pascal es para construir pirámides: imponentes, impresionantes, estructuras estáticas construidas por ejércitos que empujan bloques pesados en su lugar. Lisp es para construir organismos: estructuras imponentes, impresionantes y dinámicas construidas por cuadrillas que encajan en su lugar una multitud fluctuante de organismos más simples. Los principios de organización utilizados son los mismos en ambos casos, excepto por una extraordinaria e importante diferencia: la funcionalidad exportable y discrecional confiada al propio programador de Lisp es de un orden de magnitud superior al que se encuentra en las empresas de Pascal. Los programas Lisp llenan las librerías con funciones cuya utilidad trasciende la aplicación que las produjo. La lista, la estructura de datos nativa de Lisp, es en gran medida responsable de este crecimiento de la utilidad. La estructura simple y la aplicabilidad natural de las listas se reflejan en funciones que son sorprendentemente no idiosincráticas. En Pascal, la plétora de estructuras de datos declarables induce a especialización dentro de funciones que inhiben y penalizan la cooperación casual. Es mejor tener 100 funciones operando en una estructura de datos que tener 10 funciones operando en 10 estructuras de datos. Como resultado, la pirámide debe permanecer inalterada durante un milenio; el organismo, en cambio, debe evolucionar o perecer.

Para ilustrar esta diferencia, compare el tratamiento del material y los ejercicios de este libro al de cualquier texto de cualquier primer curso que use Pascal. No se deje engañar por la ilusión de que este es un texto digerible sólo en el MIT, propio de la raza de gente que se encuentra allí. Es precisamente lo que debe ser un libro serio sobre la programación en Lisp, sin importar quién sea el estudiante o en dónde se utilice.

Nótese que éste es un texto sobre programación, a diferencia de la mayoría de los libros de Lisp, que son usados como preparación para el trabajo en inteligencia artificial. Después de todo, las preocupaciones críticas de programación de la ingeniería de software y la inteligencia artificial tienden a fusionarse a medida que los sistemas bajo investigación se hacen más grandes. Esto explica por qué existe un interés tan creciente en Lisp por fuera de la inteligencia artificial.

Como uno podría esperar de sus objetivos, la investigación en inteligencia artificial genera muchos problemas significativos de programación. En otras culturas de programación, esta avalancha de problemas engendra nuevos lenguajes. Ciertamente, en cualquier tarea de programación muy grande, un principio organizativo útil es controlar y aislar el tráfico dentro de los módulos de tareas mediante la invención de lenguajes. Estos lenguajes tienden a volverse menos primitivos a medida que uno se acerca a los límites del sistema donde los humanos interactuamos con más frecuencia. Como resultado, estos sistemas contienen funciones complejas de procesamiento de lenguaje reproducidas muchas veces. Lisp tiene una sintaxis y una semántica tan simples que el *análisis sintáctico* `(NdT: "parsing" en inglés)` puede ser tratado como una tarea elemental. Por ello, la tecnología del análisis sintáctico no juega casi ningún papel en los programas Lisp, y la construcción de procesadores de lenguaje es raramente un impedimento para el ritmo de crecimiento y de cambio de los grandes sistemas Lisp. Finalmente, es esta misma simplicidad de sintaxis y de semántica la responsable de la carga y de la libertad que soportan todos los programadores de Lisp. Ningún programa Lisp de cualquier tamaño que supere unas cuantas líneas puede ser escrito sin ser saturado con funciones discrecionales. Invente y ajuste; ¡Haga adaptaciones y reinvente! Nosotros brindamos por el programador de Lisp que escribe sus pensamientos entre nidos de paréntesis.

Alan J. Perlis<br>
New Haven, Connecticut